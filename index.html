<!doctype html>
<html>
<head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.11.0/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bree+Serif&family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Confessional of Future Dreams</title>
<style>
body {
  font-family: "IBM Plex Mono", monospace;
  background: url('https://i-p.rmcdn.net/6564f807fd804900278f36db/5175659/image-252d07f8-1150-4519-a6fe-f76626da04c4.png?e=webp&nll=true&cX=0&cY=108&cW=1978&cH=881') no-repeat center center fixed;
  background-size: cover;
  color: white;
  text-align: center;
  padding: 40px;
}
h2 { font-size: 26px; margin-bottom: 20px; }
button {
  font-family: "IBM Plex Mono", monospace;
  background: rgba(255,255,255,0.15);
  color: white;
  border: 1px solid rgba(255,255,255,0.4);
  padding: 12px 18px;
  margin: 6px;
  font-size: 16px;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.2s ease;
  backdrop-filter: blur(5px);
}
button:hover:not(:disabled) { background: rgba(255,255,255,0.25); }
button:disabled { opacity: 0.4; cursor: default; }
.timer { font-size: 18px; margin-top: 12px; }
audio { display: block; margin: 20px auto; width: 100%; max-width: 400px; }
.status { margin-top: 12px; font-size: 17px; }
#photoPreview { display: none; margin-top:12px; max-width:300px; border-radius:10px; }
</style>
</head>
<body>
<h2>Confessional of Future Dreams</h2>

<div>
  <button id="recordBtn">Record</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="stopBtn" disabled>Stop</button>
  <button id="resetBtn" disabled>Record Again</button>
</div>

<div class="timer" id="timer">00:00 / 00:30</div>
<audio id="player" controls></audio>

<div style="margin-top:12px">
  <button id="photoBtn" disabled>Take Picture</button>
  <button id="retakeBtn" style="display:none;">Retake Photo</button>
</div>
<img id="photoPreview" />

<div style="margin-top:12px">
  <button id="submitBtn" disabled>Submit My Future Dream</button>
</div>

<div class="status" id="status"></div>

<script>
const MAX_SECONDS = 30;
let mediaRecorder, audioStream, chunks = [];
let recordedBlob = null, timerInterval = null, seconds = 0;
let photoBlob = null;

const recordBtn = document.getElementById('recordBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const resetBtn = document.getElementById('resetBtn');
const submitBtn = document.getElementById('submitBtn');
const player = document.getElementById('player');
const photoBtn = document.getElementById('photoBtn');
const retakeBtn = document.getElementById('retakeBtn');
const photoPreview = document.getElementById('photoPreview');
const statusEl = document.getElementById('status');
const timerEl = document.getElementById('timer');

// ----- Audio Functions -----
function updateTimer() {
  seconds++;
  if (seconds >= MAX_SECONDS) stopRecording();
  const mm = String(Math.floor(seconds / 60)).padStart(2,'0');
  const ss = String(seconds % 60).padStart(2,'0');
  timerEl.textContent = `${mm}:${ss} / 00:30`;
}

async function startRecording() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    alert('Microphone not supported on this device.');
    return;
  }
  try {
    audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(audioStream);
  } catch(err) {
    statusEl.textContent = 'Mic access denied: ' + err.message;
    return;
  }

  chunks = []; seconds = 0;
  timerInterval = setInterval(updateTimer, 1000);
  mediaRecorder.ondataavailable = e => chunks.push(e.data);
  mediaRecorder.onstop = convertToMp3;

  mediaRecorder.start();
  statusEl.textContent = 'Recording...';
  recordBtn.disabled = true;
  pauseBtn.disabled = false;
  stopBtn.disabled = false;
  resetBtn.disabled = true;
  submitBtn.disabled = true;
  photoBtn.disabled = true;
}

function pauseResume() {
  if (!mediaRecorder) return;
  if (mediaRecorder.state === 'recording') {
    mediaRecorder.pause();
    pauseBtn.textContent = 'Resume';
    clearInterval(timerInterval);
    statusEl.textContent = 'Paused';
  } else if (mediaRecorder.state === 'paused') {
    mediaRecorder.resume();
    pauseBtn.textContent = 'Pause';
    timerInterval = setInterval(updateTimer,1000);
    statusEl.textContent = 'Recording...';
  }
}

function stopRecording() {
  if (mediaRecorder && (mediaRecorder.state==='recording'||mediaRecorder.state==='paused')) {
    mediaRecorder.stop();
    clearInterval(timerInterval);
    pauseBtn.disabled = true;
    stopBtn.disabled = true;
    photoBtn.disabled = false;
  }
}

function resetRecording() {
  recordedBlob = null; chunks = []; player.src = '';
  submitBtn.disabled = true; resetBtn.disabled = true;
  recordBtn.disabled = false; pauseBtn.disabled = true; stopBtn.disabled = true;
  statusEl.textContent=''; timerEl.textContent='00:00 / 00:30';
  photoBlob = null; photoPreview.style.display='none'; retakeBtn.style.display='none';
  photoBtn.disabled = true;
}

async function convertToMp3() {
  const blob = new Blob(chunks,{type:'audio/webm'});
  const arrayBuffer = await blob.arrayBuffer();
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  try {
    await audioCtx.resume();
    const decoded = await audioCtx.decodeAudioData(arrayBuffer);
    const channelData = decoded.getChannelData(0);

    const mp3encoder = new lamejs.Mp3Encoder(1, decoded.sampleRate, 128);
    const samples = new Int16Array(channelData.length);
    for(let i=0;i<channelData.length;i++) samples[i] = channelData[i]*32767;

    const mp3Data = [];
    const chunkSize=1152;
    for(let i=0;i<samples.length;i+=chunkSize){
      const sampleChunk = samples.subarray(i,i+chunkSize);
      const mp3buf = mp3encoder.encodeBuffer(sampleChunk);
      if(mp3buf.length>0) mp3Data.push(mp3buf);
    }
    const end = mp3encoder.flush();
    if(end.length>0) mp3Data.push(end);

    recordedBlob = new Blob(mp3Data,{type:'audio/mp3'});
    player.src = URL.createObjectURL(recordedBlob);
    statusEl.textContent = 'Audio recording ready.';
    resetBtn.disabled=false;
    recordBtn.disabled=false;
    pauseBtn.textContent='Pause';
    checkSubmitReady();
  } catch(err) {
    console.error('MP3 conversion failed:', err);
    statusEl.textContent = 'Audio recording failed. Try again.';
    recordedBlob = null;
  } finally {
    if(audioStream) audioStream.getTracks().forEach(t=>t.stop());
  }
}

// ----- Photo Functions -----
photoBtn.addEventListener('click', capturePhoto);
retakeBtn.addEventListener('click', capturePhoto);

function capturePhoto() {
  const input = document.createElement('input');
  input.type='file'; input.accept='image/*'; input.capture='environment';
  input.onchange = () => {
    const file = input.files[0];
    if(!file) return;
    photoBlob = file;
    const reader = new FileReader();
    reader.onload = e => {
      photoPreview.src = e.target.result;
      photoPreview.style.display = 'block';
      statusEl.textContent = 'Picture ready.';
      retakeBtn.style.display = 'inline-block';
      checkSubmitReady();
    };
    reader.readAsDataURL(file);
  };
  input.click();
}

function checkSubmitReady() {
  submitBtn.disabled = !(recordedBlob && photoBlob);
}

// ----- Submit -----
async function submitAndReset() {
  if (!recordedBlob && !photoBlob) return;

  statusEl.textContent = 'Thank you for submitting!';
  submitBtn.disabled = true;

  const zip = new JSZip();
  if(recordedBlob) zip.file('MyFutureDream.mp3', recordedBlob);
  if(photoBlob) zip.file('MyFutureDreamPhoto.jpg', photoBlob);

